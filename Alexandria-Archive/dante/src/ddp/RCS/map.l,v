head	1.4;
access;
symbols;
locks;
comment	@ * @;


1.4
date	98.12.22.23.13.17;	author dante;	state Exp;
branches;
next	1.3;

1.3
date	98.12.22.22.49.41;	author dante;	state Exp;
branches;
next	1.2;

1.2
date	95.02.17.15.41.21;	author dante;	state Exp;
branches;
next	1.1;

1.1
date	88.09.28.10.03.05;	author dante;	state Exp;
branches;
next	;


desc
@lex source for character mapping
@


1.4
log
@Changed lots of "char" to "unsigned char" to match lex declarations.
@
text
@%{
#define	THIS_IS_MAP
#include "map.h"
/*
 * The string array mapstr[TERMINAL][SEQUENCE] contains the strings to be
 * output for each escape sequence for each terminal.
 */
static unsigned char *mapstr[2][58] = {
	/*
	 * Strings for the DEC VT200 and Rainbow
	 */
	{
#define BOLD		0
	(unsigned char *)"\033[1m",
#define ITALIC		1
	(unsigned char *)"\033[4m",
#define ROMAN		2
	(unsigned char *)"\033[0m",
#define DEGREE		3
	(unsigned char *)"\260",
#define L_EUROPE	4
	(unsigned char *)"\253",
#define R_EUROPE	5
	(unsigned char *)"\273",
#define UP_AE		6
	(unsigned char *)"\306",
#define LOW_AE		7
	(unsigned char *)"\346",
#define UP_OE		8
	(unsigned char *)"\327",
#define LOW_OE		9
	(unsigned char *)"\367",
#define UP_GR_A		10	/* UPper case GRave A */
	(unsigned char *)"\300",
#define LOW_GR_A	11
	(unsigned char *)"\340",
#define UP_GR_E		12
	(unsigned char *)"\310",
#define LOW_GR_E	13
	(unsigned char *)"\350",
#define UP_GR_I		14
	(unsigned char *)"\314",
#define LOW_GR_I	15
	(unsigned char *)"\354",
#define UP_GR_O		16
	(unsigned char *)"\322",
#define LOW_GR_O	17
	(unsigned char *)"\362",
#define UP_GR_U		18
	(unsigned char *)"\331",
#define LOW_GR_U	19
	(unsigned char *)"\371",
#define UP_GR_Q		20
	(unsigned char *)"\121",
#define LOW_GR_Q	21
	(unsigned char *)"\161",
#define UP_AC_A		22	/* UPper case ACute A */
	(unsigned char *)"\301",
#define LOW_AC_A	23
	(unsigned char *)"\341",
#define UP_AC_E		24
	(unsigned char *)"\311",
#define LOW_AC_E	25
	(unsigned char *)"\351",
#define UP_AC_I		26
	(unsigned char *)"\315",
#define LOW_AC_I	27
	(unsigned char *)"\355",
#define UP_AC_O		28
	(unsigned char *)"\323",
#define LOW_AC_O	29
	(unsigned char *)"\363",
#define UP_AC_U		30
	(unsigned char *)"\332",
#define LOW_AC_U	31
	(unsigned char *)"\372",
#define UP_AC_Q		32
	(unsigned char *)"\121",
#define LOW_AC_Q	33
	(unsigned char *)"\161",
#define UP_CEDILLA	34
	(unsigned char *)"\307",
#define LOW_CEDILLA	35
	(unsigned char *)"\347",
#define UP_UM_A		36	/* UPper case UMlauted A */
	(unsigned char *)"\304",
#define LOW_UM_A	37
	(unsigned char *)"\344",
#define UP_UM_E		38
	(unsigned char *)"\313",
#define LOW_UM_E	39
	(unsigned char *)"\353",
#define UP_UM_I		40
	(unsigned char *)"\317",
#define LOW_UM_I	41
	(unsigned char *)"\357",
#define UP_UM_O		42
	(unsigned char *)"\326",
#define LOW_UM_O	43
	(unsigned char *)"\366",
#define UP_UM_U		44
	(unsigned char *)"\334",
#define LOW_UM_U	45
	(unsigned char *)"\374",
#define UP_CAR_A	46	/* UPper case CAReted A */
	(unsigned char *)"\302",
#define LOW_CAR_A	47
	(unsigned char *)"\342",
#define UP_CAR_E	48
	(unsigned char *)"\312",
#define LOW_CAR_E	49
	(unsigned char *)"\352",
#define UP_CAR_I	50
	(unsigned char *)"\316",
#define LOW_CAR_I	51
	(unsigned char *)"\356",
#define UP_CAR_O	52
	(unsigned char *)"\324",
#define LOW_CAR_O	53
	(unsigned char *)"\364",
#define UP_CAR_U	54
	(unsigned char *)"\333",
#define LOW_CAR_U	55
	(unsigned char *)"\373",
#define TERMINIT	56
	(unsigned char *)"\033[62\"p",
#define TERMDEINIT	57
	(unsigned char *)"\033[61\"p\033[?7h",
	},
	/*
	 * Strings for the IBM PC
	 */
	{
/* BOLD */
	(unsigned char *)"\033[1m",
/* ITALIC */
	(unsigned char *)"\033[4m",
/* ROMAN */
	(unsigned char *)"\033[0m",
/* DEGREE */
	(unsigned char *)"\370",
/* L_EUROPE */
	(unsigned char *)"\256",
/* R_EUROPE */
	(unsigned char *)"\257",
/* UP_AE */
	(unsigned char *)"\222",
/* LOW_AE */
	(unsigned char *)"\221",
/* UP_OE */
	(unsigned char *)"OE",
/* LOW_OE */
	(unsigned char *)"oe",
/* UP_GR_A */
	(unsigned char *)"A",
/* LOW_GR_A */
	(unsigned char *)"\205",
/* UP_GR_E */
	(unsigned char *)"E",
/* LOW_GR_E */
	(unsigned char *)"\212",
/* UP_GR_I */
	(unsigned char *)"I",
/* LOW_GR_I */
	(unsigned char *)"\215",
/* UP_GR_O */
	(unsigned char *)"O",
/* LOW_GR_O */
	(unsigned char *)"\225",
/* UP_GR_U */
	(unsigned char *)"U",
/* LOW_GR_U */
	(unsigned char *)"\227",
/* UP_GR_Q */
	(unsigned char *)"Q",
/* LOW_GR_Q */
	(unsigned char *)"q",
/* UP_AC_A */
	(unsigned char *)"A",
/* LOW_AC_A */
	(unsigned char *)"\240",
/* UP_AC_E */
	(unsigned char *)"\220",
/* LOW_AC_E */
	(unsigned char *)"\202",
/* UP_AC_I */
	(unsigned char *)"I",
/* LOW_AC_I */
	(unsigned char *)"\241",
/* UP_AC_O */
	(unsigned char *)"O",
/* LOW_AC_O */
	(unsigned char *)"\242",
/* UP_AC_U */
	(unsigned char *)"U",
/* LOW_AC_U */
	(unsigned char *)"\243",
/* UP_AC_Q */
	(unsigned char *)"Q",
/* LOW_AC_Q */
	(unsigned char *)"q",
/* UP_CEDILLA */
	(unsigned char *)"\200",
/* LOW_CEDILLA */
	(unsigned char *)"\207",
/* UP_UM_A */
	(unsigned char *)"A",
/* LOW_UM_A */
	(unsigned char *)"\204",
/* UP_UM_E */
	(unsigned char *)"E",
/* LOW_UM_E */
	(unsigned char *)"\211",
/* UP_UM_I */
	(unsigned char *)"I",
/* LOW_UM_I */
	(unsigned char *)"\213",
/* UP_UM_O */
	(unsigned char *)"O",
/* LOW_UM_O */
	(unsigned char *)"\224",
/* UP_UM_U */
	(unsigned char *)"U",
/* LOW_UM_U */
	(unsigned char *)"\232",
/* UP_CAR_A */
	(unsigned char *)"A",
/* LOW_CAR_A */
	(unsigned char *)"\203",
/* UP_CAR_E */
	(unsigned char *)"E",
/* LOW_CAR_E */
	(unsigned char *)"\210",
/* UP_CAR_I */
	(unsigned char *)"I",
/* LOW_CAR_I */
	(unsigned char *)"\214",
/* UP_CAR_O */
	(unsigned char *)"O",
/* LOW_CAR_O */
	(unsigned char *)"\223",
/* UP_CAR_U */
	(unsigned char *)"U",
/* LOW_CAR_U */
	(unsigned char *)"\226",
/* TERMINIT */
	(unsigned char *)"",
/* TERMDEINIT */
	(unsigned char *)"",
	}
};

#define map(i)	(mapstr[termtype][i])

/*
 * Arrange for yylex to work on a single string rather than on stdin.
 * The results are put into another string rather than written to stdout.
 */
#undef	getc
#define	getc(x)	(*lexinp++)
#undef	ECHO
#define	ECHO	outs(yytext)
#undef	output
#define	output(c)	(*lexoutp++=(c))
#define	yywrap()	(*lexoutp = '\0',1)
#define	outs(s)	{if(italics_suspended) { \
			setmode(ITALIC); \
			italics_suspended = 0; \
		} \
		for(lexworkp=(mapon?(s):yytext); *lexworkp; *lexoutp++ = *lexworkp++); \
		}
#define setmode(m)	{for(lexmodep=(mapon?map(m):yytext); *lexmodep; *lexoutp++ = *lexmodep++);}

%}
VOWEL		[AaEeIiOoUu]
MAPPINGON	\002			/* STX or ^B */
MAPPINGOFF	\001			/* SOH or ^A */
%%
	register unsigned char *lexworkp, *lexmodep;
	register int mapon = 1;		/* enables mapping */
 /*
 * We go through a bit of extra work to work around a BRS bug.  If a line is italicized,
 * ie underscored, beyond the end of the line, the indentation blanks on the next line
 * are also underscored, which looks ugly.  So we keep track of this situation with
 * some state variables - italics and italics_suspended - and un-underscore those
 * leading blanks on the lines.
 */
	static int	italics = 0, italics_suspended = 0;

" "*\n		{
			outs((unsigned char *)"\n");
			if (italics) {
				/*
				 * end of an underscored line; need to turn off underscoring.
				 */
				setmode(ROMAN);
				italics_suspended++;
			}
		}
MAPPINGON	mapon = 1;
MAPPINGOFF	mapon = 0;
"|"		setmode(BOLD);
"^"		{setmode(ITALIC); italics++;}
\+[a-zA-Z]+~	outs(map(DEGREE));
~		{setmode(ROMAN); italics = 0;}
"<<<"|">>>"	ECHO;
"<"		outs(map(L_EUROPE));
">"		outs(map(R_EUROPE));
[^ ]		outs(yytext);
@@@@ae		outs(map(LOW_AE));
@@@@A[eE]		outs(map(UP_AE));
@@@@oe		outs(map(LOW_OE));
@@@@O[eE]		outs(map(UP_OE));
@@({VOWEL}|[Qq])	{
		switch (yytext[1]) {		/* accent grave */
			case 'A':	outs(map(UP_GR_A)); break;
			case 'a':	outs(map(LOW_GR_A)); break;
			case 'E':	outs(map(UP_GR_E)); break;
			case 'e':	outs(map(LOW_GR_E)); break;
			case 'I':	outs(map(UP_GR_I)); break;
			case 'i':	outs(map(LOW_GR_I)); break;
			case 'O':	outs(map(UP_GR_O)); break;
			case 'o':	outs(map(LOW_GR_O)); break;
			case 'U':	outs(map(UP_GR_U)); break;
			case 'u':	outs(map(LOW_GR_U)); break;
			case 'Q':	outs(map(UP_GR_Q)); break;
			case 'q':	outs(map(LOW_GR_Q)); break;
		};
		}

\$({VOWEL}|[QqCc]) {
		switch (yytext[1]) {		/* accent acute */
			case 'A':	outs(map(UP_AC_A)); break;
			case 'a':	outs(map(LOW_AC_A)); break;
			case 'E':	outs(map(UP_AC_E)); break;
			case 'e':	outs(map(LOW_AC_E)); break;
			case 'I':	outs(map(UP_AC_I)); break;
			case 'i':	outs(map(LOW_AC_I)); break;
			case 'O':	outs(map(UP_AC_O)); break;
			case 'o':	outs(map(LOW_AC_O)); break;
			case 'U':	outs(map(UP_AC_U)); break;
			case 'u':	outs(map(LOW_AC_U)); break;
			case 'Q':	outs(map(UP_AC_Q)); break;
			case 'q':	outs(map(LOW_AC_Q)); break;
			case 'C':	outs(map(UP_CEDILLA)); break;
			case 'c':	outs(map(LOW_CEDILLA)); break;
		};
		}

\,{VOWEL}	{
		switch (yytext[1]) {		/* umlaut */
			case 'A':	outs(map(UP_UM_A)); break;
			case 'a':	outs(map(LOW_UM_A)); break;
			case 'E':	outs(map(UP_UM_E)); break;
			case 'e':	outs(map(LOW_UM_E)); break;
			case 'I':	outs(map(UP_UM_I)); break;
			case 'i':	outs(map(LOW_UM_I)); break;
			case 'O':	outs(map(UP_UM_O)); break;
			case 'o':	outs(map(LOW_UM_O)); break;
			case 'U':	outs(map(UP_UM_U)); break;
			case 'u':	outs(map(LOW_UM_U)); break;
		};
		}

#{VOWEL}	{
		switch (yytext[1]) {		/* caret */
			case 'A':	outs(map(UP_CAR_A)); break;
			case 'a':	outs(map(LOW_CAR_A)); break;
			case 'E':	outs(map(UP_CAR_E)); break;
			case 'e':	outs(map(LOW_CAR_E)); break;
			case 'I':	outs(map(UP_CAR_I)); break;
			case 'i':	outs(map(LOW_CAR_I)); break;
			case 'O':	outs(map(UP_CAR_O)); break;
			case 'o':	outs(map(LOW_CAR_O)); break;
			case 'U':	outs(map(UP_CAR_U)); break;
			case 'u':	outs(map(LOW_CAR_U)); break;
		};
		}
%%
unsigned char *
terminit()
{
	if (termtype == MAP_NOMAP) 
		return((unsigned char *)"ERROR: no terminal type set");
	return(map(TERMINIT));
}

unsigned char *
termdeinit()
{
	return(map(TERMDEINIT));
}
@


1.3
log
@Try to eliminate trailing blanks. Doesn't work.
@
text
@d8 1
a8 1
static char *mapstr[2][58] = {
d14 1
a14 1
	"\033[1m",
d16 1
a16 1
	"\033[4m",
d18 1
a18 1
	"\033[0m",
d20 1
a20 1
	"\260",
d22 1
a22 1
	"\253",
d24 1
a24 1
	"\273",
d26 1
a26 1
	"\306",
d28 1
a28 1
	"\346",
d30 1
a30 1
	"\327",
d32 1
a32 1
	"\367",
d34 1
a34 1
	"\300",
d36 1
a36 1
	"\340",
d38 1
a38 1
	"\310",
d40 1
a40 1
	"\350",
d42 1
a42 1
	"\314",
d44 1
a44 1
	"\354",
d46 1
a46 1
	"\322",
d48 1
a48 1
	"\362",
d50 1
a50 1
	"\331",
d52 1
a52 1
	"\371",
d54 1
a54 1
	"\121",
d56 1
a56 1
	"\161",
d58 1
a58 1
	"\301",
d60 1
a60 1
	"\341",
d62 1
a62 1
	"\311",
d64 1
a64 1
	"\351",
d66 1
a66 1
	"\315",
d68 1
a68 1
	"\355",
d70 1
a70 1
	"\323",
d72 1
a72 1
	"\363",
d74 1
a74 1
	"\332",
d76 1
a76 1
	"\372",
d78 1
a78 1
	"\121",
d80 1
a80 1
	"\161",
d82 1
a82 1
	"\307",
d84 1
a84 1
	"\347",
d86 1
a86 1
	"\304",
d88 1
a88 1
	"\344",
d90 1
a90 1
	"\313",
d92 1
a92 1
	"\353",
d94 1
a94 1
	"\317",
d96 1
a96 1
	"\357",
d98 1
a98 1
	"\326",
d100 1
a100 1
	"\366",
d102 1
a102 1
	"\334",
d104 1
a104 1
	"\374",
d106 1
a106 1
	"\302",
d108 1
a108 1
	"\342",
d110 1
a110 1
	"\312",
d112 1
a112 1
	"\352",
d114 1
a114 1
	"\316",
d116 1
a116 1
	"\356",
d118 1
a118 1
	"\324",
d120 1
a120 1
	"\364",
d122 1
a122 1
	"\333",
d124 1
a124 1
	"\373",
d126 1
a126 1
	"\033[62\"p",
d128 1
a128 1
	"\033[61\"p\033[?7h",
d135 1
a135 1
	"\033[1m",
d137 1
a137 1
	"\033[4m",
d139 1
a139 1
	"\033[0m",
d141 1
a141 1
	"\370",
d143 1
a143 1
	"\256",
d145 1
a145 1
	"\257",
d147 1
a147 1
	"\222",
d149 1
a149 1
	"\221",
d151 1
a151 1
	"OE",
d153 1
a153 1
	"oe",
d155 1
a155 1
	"A",
d157 1
a157 1
	"\205",
d159 1
a159 1
	"E",
d161 1
a161 1
	"\212",
d163 1
a163 1
	"I",
d165 1
a165 1
	"\215",
d167 1
a167 1
	"O",
d169 1
a169 1
	"\225",
d171 1
a171 1
	"U",
d173 1
a173 1
	"\227",
d175 1
a175 1
	"Q",
d177 1
a177 1
	"q",
d179 1
a179 1
	"A",
d181 1
a181 1
	"\240",
d183 1
a183 1
	"\220",
d185 1
a185 1
	"\202",
d187 1
a187 1
	"I",
d189 1
a189 1
	"\241",
d191 1
a191 1
	"O",
d193 1
a193 1
	"\242",
d195 1
a195 1
	"U",
d197 1
a197 1
	"\243",
d199 1
a199 1
	"Q",
d201 1
a201 1
	"q",
d203 1
a203 1
	"\200",
d205 1
a205 1
	"\207",
d207 1
a207 1
	"A",
d209 1
a209 1
	"\204",
d211 1
a211 1
	"E",
d213 1
a213 1
	"\211",
d215 1
a215 1
	"I",
d217 1
a217 1
	"\213",
d219 1
a219 1
	"O",
d221 1
a221 1
	"\224",
d223 1
a223 1
	"U",
d225 1
a225 1
	"\232",
d227 1
a227 1
	"A",
d229 1
a229 1
	"\203",
d231 1
a231 1
	"E",
d233 1
a233 1
	"\210",
d235 1
a235 1
	"I",
d237 1
a237 1
	"\214",
d239 1
a239 1
	"O",
d241 1
a241 1
	"\223",
d243 1
a243 1
	"U",
d245 1
a245 1
	"\226",
d247 1
a247 1
	"",
d249 1
a249 1
	"",
d279 1
a279 1
	register char *lexworkp, *lexmodep;
d291 1
a291 1
			outs("\n");
d380 1
a380 1
char *
d384 1
a384 1
		return("ERROR: no terminal type set");
d388 1
a388 1
char *
@


1.2
log
@handle degrees, other refinements.
This was the production version for years, until 1995.
@
text
@d260 1
a260 1
#define	getc()	(*lexinp++)
d266 7
a272 1
#define	outs(s)	{for(lexworkp=(mapon?(s):yytext); *lexworkp; *lexoutp++ = *lexworkp++);}
d279 1
a279 1
	register char *lexworkp;
d281 19
d302 2
a303 2
"|"		outs(map(BOLD));
"^"		outs(map(ITALIC));
d305 1
a305 1
~		outs(map(ROMAN));
d309 1
@


1.1
log
@Initial revision
@
text
@d253 1
a253 1
#define map(s)	(mapstr[termtype][s])
d266 2
a267 1
#define	outs(s)	{for(lexworkp=s; *lexworkp; *lexoutp++ = *lexworkp++);}
d270 2
d274 3
d279 1
a279 1
\+[^~]+~	outs(map(DEGREE));
@
