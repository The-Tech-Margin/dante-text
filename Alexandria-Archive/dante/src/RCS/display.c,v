head     1.6;
access   ;
symbols  ;
locks    ;
comment  @ * @;


1.6
date     86.09.30.14.22.40;  author dante;  state Exp;
branches ;
next     1.5;

1.5
date     85.12.04.13.56.33;  author dante;  state Exp;
branches ;
next     1.4;

1.4
date     85.07.31.15.33.59;  author dante;  state Exp;
branches ;
next     1.3;

1.3
date     85.07.31.14.59.43;  author dante;  state Exp;
branches ;
next     1.2;

1.2
date     85.06.11.18.52.04;  author dante;  state Exp;
branches ;
next     1.1;

1.1
date     85.06.11.17.33.22;  author dante;  state Exp;
branches ;
next     ;


desc
@Generic program to display DDP escape sequences
@


1.6
log
@use LITOUT instead of RAW, so flow control still works.
@
text
@/*	$Header: display.c,v 1.5 85/12/04 13:56:33 dante Exp $
 *
 *	DISPLAY.C - convert "standard" Dante escapes into character sequences
 *		    that are displayable on micros or terminals
 *
 *	Usage
 *		DISPLAY  [-p] [-c] [-f]	[ <infile>  [ <outfile> ] ]
 *
 *		File names default to stdin and stdout respectively.  If
 *		<infile> is "-", stdin is used.
 *
 *		The -p flag causes non-representable characters to be
 *		preserved in escape form.  Otherwise they are shown plain.
 *
 *		The -c and -f flags SURPRESS conversion of special
 *		characters and of font codes, repsectively.
 */


/*
 *	Exactly one of the following defines should be used to select
 *	the particular micro or terminal.
 */

#define RAINBOW		/* DEC Rainbow microcomputer */
/* #define IBMPC		/* IBM Personal Computer + ANSI.SYS driver */
/* #define UNIX200		/* VT200 (VT100 mode) as Unix terminal */

/*
 *	Specific characteristics implied by the primary display types
 */

#ifdef	RAINBOW
#define	VT200
#define ANSI
#define TABLES
#endif

#ifdef	IBMPC
#define	ANSI
#define TABLES
#endif

#ifdef	UNIX200
#define VT200
#define ANSI
#define TABLES
#define UNIX
#endif


#include <stdio.h>
#include "display.h"

#ifdef	UNIX
#include <sys/ioctl.h>
#include <signal.h>
#include <fcntl.h>
#define strchr	index
int cleanup();
int localmode;
int filedes;
#endif

#ifdef VT200
#define	SET_VT200_MODE	"\033[62\"p"
#define	SET_VT100_MODE	"\033[61\"p"
#endif

FILE *in, *out;

main(argc,argv)
	int argc;
	char *argv[];
{
	char buf[MAXLINE], *display();
	int pflag = 0;
	int cflag = 1, fflag = 1;

	while (--argc > 0 && **++argv == '-' && *((*argv)+1)) {
		switch (*(++*argv)) {
			case 'p':
				pflag++;
				break;
			case 'c':
				cflag = 0;
				break;
			case 'f':
				fflag = 0;
				break;
			default:
				fprintf(stderr,"display: bad arg: %s\n", *argv);
				exit (1);
		}
	}

	switch (argc) {
	case 0:
		in = stdin;
		out = stdout;
		break;
	case 1:
		out = stdout;
		goto openin;
	case 2:
		if ((out = fopen(argv[1],"a")) == NULL) {
			fprintf(stderr,"Cannot open %s\n", argv[1]);
			exit (1);
		}
openin:
		if (!strcmp(argv[0],"-")) {
			in = stdin;
		} else if ((in = fopen(argv[0],"r")) == NULL) {
			fprintf(stderr,"Cannot open %s\n", argv[0]);
			exit (1);
		}
	}

#ifdef	UNIX
	/*
	 * If we are sending output from Unix to a tty, then go into
	 * LITOUT mode so we have an 8-bit datapath.  
	 */
	if (isatty(filedes = fileno(out))) {
		if (ioctl(filedes,TIOCLGET,&localmode) == -1) {
			perror("display: ioctl TIOCLGET");
			exit(1);
		}
		localmode |= LLITOUT;
		if (ioctl(filedes,TIOCLSET,&localmode) == -1) {
			perror("display: ioctl TIOCLSET");
			exit(1);
		}
		if (signal(SIGINT,SIG_IGN) != SIG_IGN)
			signal(SIGINT,cleanup);
	}
#ifdef VT200
	fputs(SET_VT200_MODE, out);
#endif
#endif

	while (fgets(buf,MAXLINE,in)) {
		fputs(display(buf,pflag,cflag,fflag), out);
#ifdef	UNIX
		fputc('\r',out);	/* needed 'cuz of RAW mode */
#endif
	}

	cleanup();
}


cleanup()
{
#ifdef UNIX
#ifdef VT200
	fputs(SET_VT100_MODE, out);
#endif
	fflush(out);
	localmode &= ~LLITOUT;
	(void)ioctl(filedes,TIOCLSET,&localmode);
#endif
	fclose(out);
	exit(0);
}

/*
 *	display - convert standard Dante into displayable sequences.
 *		If the preserve flag is set, keep the escape sequence for
 *		characters that cannot be represented.	Otherwise, use
 *		a best guess at a representation, probably the plain 
 *		character.  The cflag and fflag control conversion of
 *		characters and fonts.
 *
 *		Out-of-sequence font change codes - essentially codes
 *		saying "go to foo" when we are already using foo -
 *		are passed through unchanged to output.
 *
 *		This version does NOT implement Greek characters.  The
 *		Rainbow doesn't display them anyway.
 */


char *display(s,preserve,dochars,dofonts)
	char *s;
	int preserve,dochars,dofonts;
{
	char buf[MAXLINE], *b, c, *p, *advcpy(), *strchr();
	int diacritic;
	static int doing_bold = 0, doing_italic = 0;

	b = buf;
	do {
		switch (*s) {

		case STDBOLD:
			if (!doing_bold && dofonts) {
				b = advcpy(b, DISPLAYBOLD);
				doing_bold++;
			} else {
				*b++ = *s;
			}
			break;

		case STDITALIC:
			if (!doing_italic && dofonts) {
				b = advcpy(b, DISPLAYITALIC);
				doing_italic++;
			} else {
				*b++ = *s;
			}
			break;

		case STDNORMAL:
			if (doing_bold || doing_italic) {
				b = advcpy(b, DISPLAYNORMAL);
				doing_bold = doing_italic = 0;
			} else {
				*b++ = *s;
			}
			break;

		case STDDEGREE:
			if (dochars && DISPLAYDEGREE)
				*b++ = DISPLAYDEGREE;
			else
				*b++ = STDDEGREE;
			break;

		case STDLQUOTE:
			if (dochars && DISPLAYLQUOTE)
				*b++ = DISPLAYLQUOTE;
			else
				*b++ = STDLQUOTE;
			break;

		case STDRQUOTE:
			if (dochars && DISPLAYRQUOTE)
				*b++ = DISPLAYRQUOTE;
			else
				*b++ = STDRQUOTE;
			break;

		case STDGRAVE:
			diacritic = GRAVE;
			goto dodi;

		case STDACUTE:
			diacritic = ACUTE;
			goto dodi;

		case STDCARET:
			diacritic = CARET;
			goto dodi;

		case STDUMLAUT:
			diacritic = UMLAUT;
dodi:
			if (dochars) {
				if ((p = strchr(plain, *(s+1))) != NULL) {
					s++;
					if (c = foreign[p-plain][diacritic])
						*b++ = c;
					else {
						if (preserve)
							*b++ = *(s-1);
						*b++ = *s;
					}
				} else if (diacritic == GRAVE && *(s+1) == STDGRAVE) {
					switch (*(s+2)) {
						case 'A':
							*b++ = LIGAE;
							goto endlig;
						case 'a':
							*b++ = LIGae;
							goto endlig;
						case 'O':
							*b++ = LIGOE;
							goto endlig;
						case 'o':
							*b++ = LIGoe;
						endlig:
							s += 3;
							break;
						default:
							*b++ = *s;
					}
				} else {
					*b++ = *s;
				}
			} else {	/* escape for unknown char */
				*b++ = *s;
			}
			break;

		default:
			*b++ = *s;
		}
	} while (*s++);

	return buf;
}





/*
 *	advcpy - like strcpy except return pointer to ending NULL of target
 */

static char *advcpy(t,s)
	register char *t, *s;
{
	do  {
		*(t++) = *s;
	} while (*(s++));
	return (t-1);
}
@


1.5
log
@change from using SIGINT for aborting to using SIGIO.
@
text
@d1 1
a1 1
/*	$Header: display.c,v 1.4 85/07/31 15:33:59 dante Exp $
d25 1
a25 1
/* #define RAINBOW		/* DEC Rainbow microcomputer */
d27 1
a27 1
#define UNIX200		/* VT200 (VT100 mode) as Unix terminal */
d61 1
a61 1
struct sgttyb ttybuf;
d122 1
a122 3
	 * RAW mode so we have an 8-bit datapath.  Since RAW prevents
	 * ^C being recognize, we use SIGIO on standard in to stop the
	 * program if the user types any key.
d125 2
a126 2
		if (ioctl(filedes,TIOCGETP,&ttybuf) == -1) {
			perror("display: ioctl TIOCGETP");
d129 3
a131 3
		ttybuf.sg_flags |= RAW;
		if (ioctl(filedes,TIOCSETP,&ttybuf) == -1) {
			perror("display: ioctl TIOCSETP");
d134 2
a135 5
		if (fcntl(0,F_SETFL,FASYNC) < 0) {
			perror("display: fcntl");
			exit(1);
		}
		(void)signal(SIGIO, cleanup);
d139 2
a140 2
#endif VT200
#endif UNIX
d159 3
a161 2
	ttybuf.sg_flags &= ~RAW;
	(void)ioctl(filedes,TIOCSETP,&ttybuf);
d163 1
d252 4
d313 1
a313 1
	char *t, *s;
@


1.4
log
@added TABLES ifdef
@
text
@d1 1
a1 1
/*	$Header: display.c,v 1.3 85/07/31 14:59:43 dante Exp $
d25 1
a25 1
#define RAINBOW		/* DEC Rainbow microcomputer */
d27 1
a27 1
/* #define UNIX200		/* VT200 (VT100 mode) as Unix terminal */
d56 1
d58 1
a58 1
#include <sgtty.h>
d120 6
d136 5
a141 2
	if (signal(SIGINT, SIG_IGN) != SIG_IGN)
		(void)signal(SIGINT, cleanup);
d144 2
a145 2
#endif
#endif
d150 1
a150 1
		fputc('\r',out);
@


1.3
log
@implemented ae and oe ligatures.
@
text
@d1 1
a1 1
/*	$Header$
d25 1
a25 1
/* #define RAINBOW		/* DEC Rainbow microcomputer */
d27 1
a27 1
#define UNIX200		/* VT200 (VT100 mode) as Unix terminal */
d36 1
d41 1
d47 1
@


1.2
log
@fixed bug in processing of ",~".  Added -c and -f args.
@
text
@d1 2
a2 1
/*
d245 30
a274 7
			if (dochars && (p = strchr(plain, *(s+1))) != NULL) {
				s++;
				if (c = foreign[p-plain][diacritic])
					*b++ = c;
				else {
					if (preserve)
						*b++ = *(s-1);
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 *		DISPLAY  [-p]	[ <infile>  [ <outfile> ] ]
d13 3
d73 1
d75 15
a89 4
	if (!strcmp(argv[1],"-p")) {
		pflag++;
		argc--;
		argv++;
d91 1
d93 1
a93 1
	case 1:
d97 1
a97 1
	case 2:
d100 3
a102 3
	case 3:
		if ((out = fopen(argv[2],"a")) == NULL) {
			fprintf(stderr,"Cannot open %s\n", argv[2]);
d106 1
a106 1
		if (!strcmp(argv[1],"-")) {
d108 2
a109 2
		} else if ((in = fopen(argv[1],"r")) == NULL) {
			fprintf(stderr,"Cannot open %s\n", argv[1]);
d134 1
a134 1
		fputs(display(buf,pflag), out);
d157 1
a157 1
 *	display - convert standard Dante into microcomputer sequences.
d161 2
a162 1
 *		character.
d173 1
a173 1
char *display(s,preserve)
d175 1
a175 1
	int preserve;
d186 1
a186 1
			if (!doing_bold) {
d195 1
a195 1
			if (!doing_italic) {
d213 1
a213 1
			if (DISPLAYDEGREE)
d215 1
a215 1
			else if (preserve)
d220 1
a220 1
			if (DISPLAYLQUOTE)
d227 1
a227 1
			if (DISPLAYRQUOTE)
d244 2
a245 1
			if ((p = strchr(plain, *(++s))) != NULL) {
d253 2
a254 2
			} else {		/* escape for unknown char */
				*b++ = *(--s);
@
