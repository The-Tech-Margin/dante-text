head	1.12;
access;
symbols;
locks;
comment	@ * @;


1.12
date	98.12.13.15.51.17;	author dante;	state Exp;
branches;
next	1.11;

1.11
date	93.04.13.12.41.45;	author dante;	state Exp;
branches;
next	1.10;

1.10
date	91.05.28.22.30.28;	author dante;	state Exp;
branches;
next	1.9;

1.9
date	88.09.30.12.00.39;	author dante;	state Exp;
branches;
next	1.8;

1.8
date	88.09.30.11.27.17;	author dante;	state Exp;
branches;
next	1.7;

1.7
date	88.09.20.17.10.28;	author dante;	state Exp;
branches;
next	1.6;

1.6
date	88.09.14.11.43.02;	author dante;	state Exp;
branches;
next	1.5;

1.5
date	87.11.17.14.36.57;	author dante;	state Exp;
branches;
next	1.4;

1.4
date	87.07.24.14.50.55;	author dante;	state Exp;
branches;
next	1.3;

1.3
date	87.04.12.12.42.38;	author dante;	state Exp;
branches;
next	1.2;

1.2
date	87.04.07.16.59.17;	author dante;	state Exp;
branches;
next	1.1;

1.1
date	87.03.27.11.35.06;	author dante;	state Exp;
branches;
next	;


desc
@Pre-load filter for commentary or proemio files
@


1.12
log
@added warning if end_line < start_line
@
text
@/*
 *	dbloadf - Filter for just before database loading
 *
 *	Usage
 *		dbloadf  <flags>  [ <infile>  [ <outfile> ] ]
 *
 *		flags:
 *			-c<commentary>
 *			-l<language>
 *			-p<publication year>
 *			-t<DTYP value>	[optional]
 *			-a<cantica>	[optional]
 *			-o<canto>	[optional]
 *			-r		[copyrighted]
 *			-d		[debug]
 *
 *	File names default to stdin and stdout respectively.  If
 *	<infile> is "-", stdin is used.
 *
 */

#ifndef lint
static char version[] = "$Header: /amber/Dante/src/RCS/dbloadf.c,v 1.11 1993/04/13 12:41:45 dante Exp $";
#endif

#include <stdio.h>
#include <ctype.h>
#include <strings.h>

#define	MAXLINE		512

#define FMTOFF		"<<<FORMATTING-OFF>>>"
#define FMTON		"<<<FORMATTING-ON>>>"

/*
 *	Line types, as returned by linetype()
 */
#define LINENOS		0
#define BLANK		1
#define TAB		2
#define INDENTED	3
#define NOBLANK		4
#define NOTA		5
#define DOC_BREAK	6
#define SUMMARIUM	7
#define CONTROL		8
#define CONTROLIND	"&&"	/* indicates a control line */

char *pgmname;
char *comm = NULL, *lang = NULL, *pubdate = NULL,
     *dtyp = NULL, *cantica = NULL, *canto = NULL;
int start_line, end_line;
char line[MAXLINE];
char *textptr;
char errmsg[MAXLINE];
char attributes[MAXLINE];
int nblines, inlines;
int copyrighted = 0;

main(argc,argv)
	int argc;
	char *argv[];
{
	register int fmt_is_on, need_blank, lt, do_refs;
	long	 textchars;
	char	*langkey;
	char	 cantica_id[3];
	int debug = 0;

	pgmname = argv[0];
	while (--argc > 0 && **++argv == '-' && *(*argv + 1)) {
		switch (*(*argv + 1)) {
			case 'c':
				comm = *argv + 2;
				break;
			case 'l':
				lang = *argv + 2;
				if (!strncasecmp(lang,"Italian",strlen("Italian")))
					langkey = "IT";
				else if (!strncasecmp(lang,"Latin",strlen("Latin")))
					langkey = "LA";
				else if (!strncasecmp(lang,"English",strlen("English")))
					langkey = "EN";
				else {
					fprintf(stderr,"unrecognized language: %s\n", lang);
					exit(1);
				}
				break;
			case 'p':
				pubdate = *argv + 2;
				break;
			case 't':
				dtyp = *argv + 2;
				break;
			case 'a':
				cantica = *argv + 2;
				strncpy(cantica_id,cantica,2);
				cantica_id[2] = '\0';
				break;
			case 'o':
				canto = *argv + 2;
				break;
			case 'r':
				copyrighted++;
				break;
			case 'd':
				debug++;
				break;
			default:
				fprintf(stderr,"%s: bad arg: %s\n",pgmname,*argv);
				exit (1);
		}
	}

	switch (argc) {
	case 0:				/* no file names */
		break;
	case 1:				/* inputfile only */
		goto openin;
	case 2:
		if (freopen(argv[1],"a",stdout) == NULL) {
			sprintf(errmsg,"%s: %s", pgmname, argv[1]);
			perror(errmsg);
			exit (1);
		}
openin:
		if (strcmp(argv[0],"-")) {
			if (freopen(argv[0],"r",stdin) == NULL) {
				sprintf(errmsg,"%s: %s", pgmname, argv[0]);
				perror(errmsg);
				exit (1);
			}
		}
	}

	if (debug) {
		fprintf(stderr,"\tCOMM: %s\n\tLANG: %s\n\tPUBD: %s\n\tDTYP: %s\n\tCTCA: %s\n\tCNTO: %s\n",
			comm, lang, pubdate, dtyp, cantica, canto);
	}

	fmt_is_on = 1;
	need_blank = 0;
	textchars = 0;
	while (gets(line)) {
		inlines++;
		lt = linetype();
		if (lt == CONTROL) {
			controlline();
			continue;
		}
		if (nblines == 0 && lt == BLANK)
			continue;
		if (++nblines == 1 ||
		    lt == LINENOS || lt == NOTA || lt == SUMMARIUM || lt == DOC_BREAK) {
			if (textchars) {
				printf("..TCHR: %ld\n", textchars);
				textchars = 0;
			}
			printf("..COMM: %s\n", comm);
			printf("..LANG: %s\n", lang);
			printf("..PUBD: %s\n", pubdate);
			if (copyrighted) {
				if (strlen(attributes))
					printf("..ATTR: %s copyright\n",attributes);
				else
					printf("..ATTR: copyright\n");
			}
			printf("..LODD:\n");
			printf("..DTYP: %s\n", (lt == NOTA || lt == SUMMARIUM) ? "I" : dtyp);
			do_refs = 1;			/* assume we will */
			if (cantica && *cantica)
				printf("..CTCA: %s\n", cantica);
			else
				do_refs = 0;
			if (canto && *canto)
				printf("..CNTO: %s\n", canto);
			else
				do_refs = 0;
			if (start_line > 0) {
				printf("..LINE: %d\n", start_line);
				printf("..ENDL: %d\n", end_line);
			}
			else
				do_refs = 0;
			if (do_refs) {
				int	 l;
				printf("..REFS:\n");
				for (l = start_line; l <= end_line; l++) {
					printf("%s-A%s-O%s-L%d ",langkey,cantica_id,canto,l);
					printf("A%s-O%s-L%d\n",cantica_id,canto,l);
				}
			}
			if (lt == SUMMARIUM)
				printf("..BTXT:\n");
			else
				printf("..TEXT:\n");
			fmt_is_on = 1;
			need_blank = 0;
		}
		switch (lt) {
			case BLANK:
				need_blank = 1;
				fmt_is_on = 1;
				break;

			case TAB:
			case LINENOS:
			case NOTA:
			case SUMMARIUM:
			case DOC_BREAK:
				if (need_blank) {
					fputc('\n', stdout);
					need_blank = 0;
				}
				if (fmt_is_on == 0) {
					puts(FMTON);
					fmt_is_on = 1;
				}
				puts(textptr);
				textchars += strlen(textptr);
				break;

			case INDENTED:
				if (need_blank) {
					fputc('\n', stdout);
					need_blank = 0;
				}
				if (fmt_is_on) {
					puts(FMTOFF);
					fmt_is_on = 0;
				}
				puts(line);
				textchars += strlen(line);
				break;

			case NOBLANK:
				if (need_blank) {
					fputc('\n', stdout);
					need_blank = 0;
				}
				if (fmt_is_on == 0) {
					puts(FMTON);
					fmt_is_on = 1;
				}
				puts(line);
				textchars += strlen(line);
				break;

			default:
				fprintf(stderr,"near line %d: bad linetype\n", inlines);
				break;
		}
	}
}


/*
 *	linetype - figure out what kind of input line we have
 *
 *	side effects: sets start_line, end_line, and textptr
 */
linetype()
{
	register int col, scancount, tilde;
	int retval;

	start_line = end_line = 0;

	if (!strncmp(line,CONTROLIND,strlen(CONTROLIND))) {
		textptr = line + strlen(CONTROLIND);
		return(CONTROL);
	}

	col = 1;
	for (textptr = line; isspace(*textptr); textptr++) {
		if (*textptr == '\t')
			col = (((col + 7) / 8) * 8) + 1;
		else
			col++;
	}

	if (*textptr == '\0')
		return(BLANK);
	if (col == 1) {
		if (strcmp(textptr,"DOC_BREAK") == 0 ||
		    strcmp(textptr,"DOC-BREAK") == 0) {
			retval = DOC_BREAK;
			goto adjust;
		} else
			return(NOBLANK);
	}
	if (col != 9)
		return(INDENTED);
	if (*textptr != '|')
		return(TAB);
	
	/*
	 *  Assumed format is |%d-%d with the second number defaulting to 0,
	 *  or |keyword.
	 */
	scancount = sscanf(textptr, "|%d-%d", &start_line, &end_line);
	if (scancount >= 1) {
		retval = LINENOS;
		if (end_line == 0)
			end_line = start_line;
		if (end_line < start_line)
			fprintf(stderr,"near line %d: end line < start line\n", inlines);
		/*
		 * Move to the start of text. Note if a ~ (font reset) occurs.
		 * If it does not, then we must insert a | in front of the
		 * remaining text to maintain the original font.  For example:
		 *	"|3-4  foobar" becomes "|foobar"
		 */
adjust:
		tilde = 0;
		while (!isspace(*++textptr))
			if (*textptr == '~')
				tilde++;
		while (isspace(*++textptr)) ;
		if (tilde == 0)
			*(--textptr) = '|';
		return(retval);
	}
	if (!strncasecmp(textptr, "|Proemio",     strlen("|Proemio")) ||
	    !strncasecmp(textptr, "|Proemium",    strlen("|Proemium")) ||
	    !strncasecmp(textptr, "|Rubrica",     strlen("|Rubrica")) ||
	    !strncasecmp(textptr, "|Nota",        strlen("|Nota")) ||
	    !strncasecmp(textptr, "|Conclusione", strlen("|Conclusione")) ) {
		return(NOTA);
	}
	if (!strncasecmp(textptr, "|Summarium",   strlen("|Summarium")) ||
	    !strncasecmp(textptr, "|Table",       strlen("|Table")) ||
	    !strncasecmp(textptr, "|Deductio",    strlen("|Deductio")) ) {
		return(SUMMARIUM);
	}
	return(TAB);
}


controlline()
{
	while (isspace(*textptr))
		textptr++;
	if (!strncasecmp(textptr,"attributes",strlen("attributes")))
		strcpy(attributes,textptr+strlen("attributes"));
}
@


1.11
log
@longtime production version from July 1991 until April 1993.
@
text
@d23 1
a23 1
static char version[] = "$Header: dbloadf.c,v 1.10 91/05/28 22:30:28 dante Exp $";
d306 2
@


1.10
log
@minor change to copyright handling.  This is the production version
from Feb 89 until May 91.
@
text
@d23 1
a23 1
static char version[] = "$Header: dbloadf.c,v 1.9 88/09/30 12:00:39 dante Exp $";
d64 4
a67 2
	register int fmt_is_on, need_blank, lt;
	long textchars;
d78 10
d97 2
d170 1
d173 2
d177 2
d181 11
a191 4
				if (end_line > 0) 
					printf("..ENDL: %d\n", end_line);
				else
					printf("..ENDL: %d\n", start_line);
d250 1
a250 2
				sprintf(errmsg,"near line %d: bad linetype\n", inlines);
				fputs(errmsg,stderr);
d304 2
@


1.9
log
@Added && control line capability, starting with &&attributes line.
@
text
@d23 1
a23 1
static char version[] = "$Header$";
d148 6
a153 2
			if (copyrighted)
				printf("..ATTR: %s copyright\n",attributes);
@


1.8
log
@Added additional recognition for NOTA and SUMMARIUM text.  Converted
strcmp to strcasecmp in these cases.  Generate ENDL even if == LINE.
@
text
@d22 3
d46 2
d56 1
d133 4
d149 1
a149 1
				printf("..ATTR: copyright\n");
d239 6
d246 1
a246 1
	for (textptr = line; textptr && isspace(*textptr); textptr++) {
d304 9
@


1.7
log
@generalized proemio to nota, recognizing "nota", "Conclusione", etc.
@
text
@d25 1
d42 1
d130 1
a130 1
		    lt == LINENOS || lt == NOTA || lt == DOC_BREAK) {
d141 1
a141 1
			printf("..DTYP: %s\n", lt == NOTA ? "I" : dtyp);
d146 1
a146 1
			if (start_line > 0)
d148 9
a156 3
			if (end_line > 0) 
				printf("..ENDL: %d\n", end_line);
			printf("..TEXT:\n");
d169 1
d254 1
a254 1
	 *  or |Proemio or |Nota.
d275 5
a279 3
	if (!strncmp(textptr, "|Proemio", strlen("|Proemio")) ||
		 !strncmp(textptr, "|Nota", strlen("|Nota")) ||
		 !strncmp(textptr, "|Conclusione", strlen("|Conclusione")) ) {
d281 5
@


1.6
log
@Added copyright handling.  Fixed bug in column computation.
@
text
@d39 1
a39 1
#define PROEMIO		5
d128 1
a128 1
		    lt == LINENOS || lt == PROEMIO || lt == DOC_BREAK) {
d139 1
a139 1
			printf("..DTYP: %s\n", lt == PROEMIO ? "I" : dtyp);
d160 1
a160 1
			case PROEMIO:
d245 1
a245 1
	 *  or |Proemio.
d247 2
a248 2
	scancount = sscanf(++textptr, "%d-%d", &start_line, &end_line);
	if (scancount >= 1)
d250 15
a264 10
	else if (strncmp(textptr, "Proemio", strlen("Proemio")) == 0)
		retval = PROEMIO;
	else {
#ifdef notdef
		sprintf(errmsg,"line %d: warning: boldface at column 9:\n%s\n",
			inlines, line);
		fputs(errmsg,stderr);
#endif
		textptr--;
		return(TAB);
d266 6
a271 16

	/*
	 * Move to the start of text. Note if a ~ (font reset) occurs.
	 * If it does not, then we must insert a | in front of the
	 * remaining text to maintain the original font.  For example:
	 *	"|3-4  foobar" -> "|foobar"
	 */
adjust:
	tilde = 0;
	while (!isspace(*++textptr))
		if (*textptr == '~')
			tilde++;
	while (isspace(*++textptr)) ;
	if (tilde == 0)
		*(--textptr) = '|';
	return(retval);
@


1.5
log
@added TCHR field to count text characters.
@
text
@d14 1
d50 1
d81 3
d136 2
d222 4
a225 1
		col += *textptr == ' ' ? 1 : 8;
d253 1
d257 1
@


1.4
log
@various fixes... I forget exactly.
@
text
@d55 1
d116 1
d124 4
d164 1
d177 1
d190 1
@


1.3
log
@minor bug fix
@
text
@d36 1
a36 1
#define FEWBLANK	3
d39 1
d120 2
a121 1
		if (++nblines == 1 || lt == LINENOS || lt == PROEMIO) {
d148 1
d160 1
a160 1
			case FEWBLANK:
d211 10
a220 4
	if (col == 1)
		return(NOBLANK);
	if (col < 8)
		return(FEWBLANK);
d234 2
a235 1
		sprintf(errmsg,"line %d: bad format\n", inlines);
d237 2
a238 1
		exit(1);
d247 1
@


1.2
log
@added proemio processing.  other general improvements
@
text
@a133 1
			puts(textptr);
a135 1
			continue;
d144 2
@


1.1
log
@Initial revision
@
text
@d30 3
d38 1
d47 1
a47 1
int linecount;
d93 1
a93 1
			sprintf(errmsg,"%s: %s", pgmname, argv[1]);
d100 1
a100 1
				sprintf(errmsg,"%s: %s", pgmname, argv[0]);
d115 1
d117 1
a117 1
		if (linecount == 0 && lt == BLANK)
d119 1
a119 1
		if (++linecount == 1 || lt == LINENOS) {
d124 1
a124 2
			if (dtyp && *dtyp)
				printf("..DTYP: %s\n", dtyp);
d182 1
a182 1
				sprintf(errmsg,"near line %d: bad linetype\n", linecount);
d198 1
d216 2
a217 1
	 *  Assumed format is |%d-%d with the second number defaulting to 0.
d219 8
a226 3
	scancount = sscanf(textptr, "|%d-%d", &start_line, &end_line);
	if (scancount < 1) {
		sprintf(errmsg,"line %d: bad line range\n", linecount);
d231 1
a231 1
	 * Move past the line numbers. Note if a ~ (font reset) occurs.
d243 1
a243 1
	return(LINENOS);
@
